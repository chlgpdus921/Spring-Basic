

<p data-ke-size="size16"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">[김영한님] 스프링 핵심 원리 - 기본편</span></p>
<p data-ke-size="size16"><a href="https://inf.run/d1LX">https://inf.run/d1LX</a></p>
<figure id="og_1675591068199" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="스프링 핵심 원리 - 기본편 - 인프런 | 강의" data-og-description="스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다., - 강의 소개 | 인프런..." data-og-host="www.inflearn.com" data-og-source-url="https://inf.run/d1LX" data-og-url="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" data-og-image="https://scrap.kakaocdn.net/dn/gTidP/hyQWuQyOjJ/0cHkd9XAa8GJkTt45I0kCk/img.png?width=768&amp;height=500&amp;face=0_0_768_500,https://scrap.kakaocdn.net/dn/rzf08/hyQWDmssiy/tGVwC04JIMxhSdLGGwXGBK/img.png?width=768&amp;height=500&amp;face=0_0_768_500,https://scrap.kakaocdn.net/dn/cF5G9k/hyQYKjVJnD/OCPJ5H2R2bxe9cfBINz4j0/img.png?width=1805&amp;height=1044&amp;face=0_0_1805_1044"><a href="https://inf.run/d1LX" data-source-url="https://inf.run/d1LX">
    <div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/gTidP/hyQWuQyOjJ/0cHkd9XAa8GJkTt45I0kCk/img.png?width=768&amp;height=500&amp;face=0_0_768_500,https://scrap.kakaocdn.net/dn/rzf08/hyQWDmssiy/tGVwC04JIMxhSdLGGwXGBK/img.png?width=768&amp;height=500&amp;face=0_0_768_500,https://scrap.kakaocdn.net/dn/cF5G9k/hyQYKjVJnD/OCPJ5H2R2bxe9cfBINz4j0/img.png?width=1805&amp;height=1044&amp;face=0_0_1805_1044');">&nbsp;</div>
    <div class="og-text">
        <p class="og-title" data-ke-size="size16">스프링 핵심 원리 - 기본편 - 인프런 | 강의</p>
        <p class="og-desc" data-ke-size="size16">스프링 입문자가 예제를 만들어가면서 스프링의 핵심 원리를 이해하고, 스프링 기본기를 확실히 다질 수 있습니다., - 강의 소개 | 인프런...</p>
        <p class="og-host" data-ke-size="size16">www.inflearn.com</p>
    </div>
</a></figure>
<div class="markdown-body">
    <h2 data-ke-size="size26"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">커리큘럼</span></h2>
    <p data-ke-size="size16"><span>65 강의 (12시간 7분)</span></p>
    <h3 data-ke-size="size23"><span>싱글톤 컨테이너</span></h3>
</div>
<style type="text/css">
    .tg  {border-collapse:collapse;border-spacing:0;}
    .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        overflow:hidden;padding:10px 5px;word-break:normal;}
    .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
    .tg .tg-v0zy{background-color:#efefef;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    .tg .tg-096r{color:#000000;text-align:left;vertical-align:top}
    .tg .tg-qh0q{background-color:#c0c0c0;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    .tg .tg-f8tx{color:#000000;text-align:center;vertical-align:top}
    .tg .tg-ddj9{background-color:#c0c0c0;color:#000000;text-align:center;vertical-align:top}
    @media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;}}</style>

<div class="tg-wrap"><table class="tg" style="undefined;table-layout: fixed; width: 914px">
    <colgroup>
        <col style="width: 32px">
        <col style="width: 276px">
        <col style="width: 39px">
        <col style="width: 567px">
    </colgroup>
    <thead>
    <tr>
        <th class="tg-ddj9"> </th>
        <th class="tg-qh0q">강의 제목</th>
        <th class="tg-qh0q">시간</th>
        <th class="tg-qh0q">배운 점</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="tg-v0zy">32</td>
        <td class="tg-096r">웹 애플리케이션과 싱글톤</td>
        <td class="tg-f8tx">8</td>
        <td class="tg-096r"><a href="https://yeonni-history.tistory.com/81" target="_blank" rel="noopener noreferrer">https://yeonni-history.tistory.com/81</a><br><br>스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다. 웹 애플리케이션은 보통 여러 고객이 동시에 요청한다. 즉, 고객이 3번 요청하면 객체가 3개 생성된다.<br><br>스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때마다 객체를 새로 생성한다. <br>고객 트래픽이 초당 100이 나오면 초당 100개의 객체가 생성되고 소멸됨 -&gt; 메모리 낭비가 심함<br><br>해결방안은 해당 객체가 딱 1개만 생성되고, 생성된 객체 인스턴스를 공유하도록 설계하면 된다. -&gt; 이게 바로 싱글톤 패턴</td>
    </tr>
    <tr>
        <td class="tg-v0zy">33</td>
        <td class="tg-096r">싱글톤 패턴</td>
        <td class="tg-f8tx">15</td>
        <td class="tg-096r">싱글톤 패턴<br>- static 영역에 객체 instance 를 미리 하나 생성해서 올려둔다. 이 객체 인스턴스가 필요하면 오직 getInstance 메서드를 통해서만 조회할 수 있다. 이것을 호출하면 항상 같은 인스턴스를 반환한다. <br>- 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private로 막아서 혹시라도 외부에서 new키워드로 객체 인스턴스가 생성되는 것을 막는다. <br><br>만들어진 객체를 공유해서 효율적으로 사용할 수 있다는 장점이 있지만 수많은 문제점이  존재한다.<br><br>싱글톤 패턴의 문제점  <br>- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다. (기본적으로 넣어야할 코드가 존재) <br>- 의존관계상 클라이언트가 구체 클래스가 의존한다. -&gt; DIP위반 (getInstance를 불러와야함) <br>- 클라이언트가 구체클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다. <br>- 테스트하기 어렵다. <br>- 내부 속성을 변경하거나 초기화하기 어렵다. <br>- private 생성자로 자식 클래스를 만들기 어렵다. <br>- 유연성이 떨어진다... 안티패턴으로 불리기도 한다. <br><br>싱글토 컨테이너는 위에 있는 싱글톤 패턴의 문제점을 다 해결한다!!</td>
    </tr>
    <tr>
        <td class="tg-v0zy">34</td>
        <td class="tg-096r">싱글톤 컨테이너</td>
        <td class="tg-f8tx">7</td>
        <td class="tg-096r">스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 <br>관리한다. <span style="background-color:#F9F9F9">(ex. 동일한 memberService 반환)</span><br><br>싱글톤 컨테이너 <br>- 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.<br>- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 <br>레지스트리라 한다. <br>- 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다. <br><br>스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤만 지원하는 것은 아님. 요청할때마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.</td>
    </tr>
    <tr>
        <td class="tg-v0zy">35</td>
        <td class="tg-096r">싱글톤 방식의 주의점</td>
        <td class="tg-f8tx">14</td>
        <td class="tg-096r">객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 무상태(stateless)로로 설계해야한다.<br><br>- 특정 클라이언트에 의존적인 필드가 있음 안됨 <br>- 특정 클라이언트가 값을 변경할 수 있는 필드가 있음 안됨 <br>- 가급적 읽기만. <br>- 자바에서 공유되지 않는, 지역변수 파라미터 ThreadLocal 등을 사용해야 한다. <br><br>스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다. 스프링 빈은 항상 무상태(stateless)로 설계하자.</td>
    </tr>
    <tr>
        <td class="tg-v0zy">36</td>
        <td class="tg-096r">@Configuration과 싱글톤</td>
        <td class="tg-f8tx">13</td>
        <td class="tg-096r"><a href="https://yeonni-history.tistory.com/82" target="_blank" rel="noopener noreferrer">https://yeonni-history.tistory.com/82</a><br><br>// memberService -&gt; MemoryMemberRepository <br>// orderService -&gt; MemoryMemberRepository<br><br>AppConfig.class에서 각각 두개의 MemoryMemberRepository를 생성하면서 Singleton이 깨지는 것처럼 보임 <br><br>그러나 테스트코드를 돌리면 <span style="background-color:#F9F9F9">MemoryMemberRepository가 모두 </span>같은 인스턴스가 공유되어 사용된다. <br>AppConfig자바 코드를 보면 분명히 다른 인스턴스가 생성되는데 로그를 출력하면 bean 생성시 <span style="background-color:#F9F9F9">call AppConfig.memberRepository 한 줄만 출력됨. </span></td>
    </tr>
    <tr>
        <td class="tg-v0zy">37</td>
        <td class="tg-096r"><span style="background-color:#F9F9F9">@Configuration과 바이트코드 조작의 마법</span></td>
        <td class="tg-f8tx">15</td>
        <td class="tg-096r"><span style="background-color:#FFF">AppConfig bean 클래스 이름을 출력해보면 다음과 같은 클래스 이름이 출력된다. -&gt; </span>AppConfig$$SpringCGLIB$$0<br><br>스프링이 CGLIB<span style="background-color:#FFF"> 라는 바이트코드 조작 라이브러리를 사용해서 AppConfig클래스를 상속받은 임의의 다른 클래스를 만들고,그 다른 클래스를 스프링 빈으로 등록한 것이다.</span><br><br>임의의 다른 클래스가 바로 싱글톤이 보장되도록 해준다. <span style="background-color:#FFF">Bean이 붙은 메서드마다 스프링 빈이 존재하면 존재하는 빈 반환, 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.</span><br></td>
    </tr>
    </tbody>
</table></div>

<div class="markdown-body">
    <p data-ke-size="size16">&nbsp;</p>
    <h3 data-ke-size="size23">컴포넌트 스캔</h3>
</div>
<style type="text/css">
    .tg  {border-collapse:collapse;border-spacing:0;}
    .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        overflow:hidden;padding:10px 5px;word-break:normal;}
    .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
    .tg .tg-nwv6{background-color:#efefef;border-color:#333333;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    .tg .tg-096r{color:#000000;text-align:left;vertical-align:top}
    .tg .tg-qh0q{background-color:#c0c0c0;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    .tg .tg-f8tx{color:#000000;text-align:center;vertical-align:top}
    .tg .tg-btu1{background-color:#c0c0c0;border-color:#333333;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    @media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;}}</style>
<div class="tg-wrap"><table class="tg" style="undefined;table-layout: fixed; width: 921px">
    <colgroup>
        <col style="width: 30px">
        <col style="width: 296px">
        <col style="width: 50px">
        <col style="width: 545px">
    </colgroup>
    <thead>
    <tr>
        <th class="tg-btu1"> </th>
        <th class="tg-qh0q">강의 제목</th>
        <th class="tg-qh0q">시간</th>
        <th class="tg-qh0q">배운 점</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="tg-nwv6">38</td>
        <td class="tg-096r">컴포넌트 스캔과 의존관계 자동 주입 시작하기</td>
        <td class="tg-f8tx">19</td>
        <td class="tg-096r">설정 정보가 없어도 자동으로 스프링 빈을 등록하는 @ComponentScan. @Component가 붙은 클래스를 스캔에서 스프링 빈으로 등록한다.<br><br>의존 관계도 자동으로 주입하는 @Autowired 기능도 제공. 생성자에서 여러 의존관계를 한 번에 주입할 수 있다.  스프링 컨테이너가 자동으로 해당 스플이 빈을 찾아서 주입함. 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.  getBean(MemberRepository.class)</td>
    </tr>
    <tr>
        <td class="tg-nwv6">39</td>
        <td class="tg-096r">탐색 위치와 기본 스캔 대상</td>
        <td class="tg-f8tx">12</td>
        <td class="tg-096r">basePackages, basicPackageClasses 사용하여 탐색 시작할 package 위치 지정 가능<br>지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다. <br>따로 지정하지 않고 설정 정보 클래스의 위치를 프로젝트 최상단에 두자.  스프링 부트도 이 방법을 기본으로 제공한다. <br><br>SpringBootApplication 안에 ComponentScan이 들어있다. 스프링을 쓰면 따로 해줄 필요가 없음<br><br>컴포넌트 스캔은 @Component 뿐만 아니라 밑의 Annotation들도 같은 역할을 하면서 추가 역할 제공함<br>@Controller - 스프링 MVC 컨트롤러로 인식<br>@Repository -스프링 데이터 접근 계층으로 인식, 데이터 계층의 예외를 스프링 예외로 변환 <br>@Configuration : 스프링 설정 정보로 인식, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.<br>@Service - 스프링 비즈니스 로직에서 사용<br>특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다.</td>
    </tr>
    <tr>
        <td class="tg-nwv6">40</td>
        <td class="tg-096r">필터</td>
        <td class="tg-f8tx">9</td>
        <td class="tg-096r">스프링 빈 등록<br>includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),<br><br>스프링 빈 등록 X <br>excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)<br><br>스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 옵션을 변경하면서 사용하기 보다는 기본 설정에 최대한 맞추어 사용하는 것을 권장한다.</td>
    </tr>
    <tr>
        <td class="tg-nwv6">41</td>
        <td class="tg-096r">중복 등록과 충돌</td>
        <td class="tg-f8tx">9</td>
        <td class="tg-096r">컴포넌트 스캔에서 같은 빈 이름을 등록했을 경우<br>1. 자동 빈 등록 vs 자동 빈 등록<br>ConflictingBeanDenitionException 발생<br>2. 수동 빈 등록 vs 자동 빈 등록<br>- 수동 빈이 우선권을 가짐<br>- 수동 빈이 자동 빈을 오버라이딩 해버린다. <br><br>현실은 개발자가 의도하기 보다는, 놓친 버그. 이렇게 되었을 경우 찾기 어려운 버그가 되어버려 최근 스프링부트는 오류가 발생하도록 기본 값을 바꾸었다. -&gt; CoreApplication 실행 후 확인 가능<br><br><a href="https://yeonni-history.tistory.com/83" target="_blank" rel="noopener noreferrer">https://yeonni-history.tistory.com/83</a></td>
    </tr>
    </tbody>
</table></div>

<div class="markdown-body">
    <p data-ke-size="size16">&nbsp;</p>
    <h3 data-ke-size="size23">의존관계 자동 주입</h3>
</div>
<style type="text/css">
    .tg  {border-collapse:collapse;border-spacing:0;}
    .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        overflow:hidden;padding:10px 5px;word-break:normal;}
    .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
    .tg .tg-v0zy{background-color:#efefef;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    .tg .tg-096r{color:#000000;text-align:left;vertical-align:top}
    .tg .tg-qh0q{background-color:#c0c0c0;color:#000000;font-weight:bold;text-align:center;vertical-align:top}
    .tg .tg-j62g{background-color:#c0c0c0;color:#343434;text-align:center;vertical-align:top}
    .tg .tg-f8tx{color:#000000;text-align:center;vertical-align:top}
    @media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;}}</style>
<div class="tg-wrap"><table class="tg" style="undefined;table-layout: fixed; width: 851px">
    <colgroup>
        <col style="width: 36px">
        <col style="width: 281px">
        <col style="width: 45px">
        <col style="width: 489px">
    </colgroup>
    <thead>
    <tr>
        <th class="tg-j62g"> </th>
        <th class="tg-qh0q">강의 제목</th>
        <th class="tg-qh0q">시간</th>
        <th class="tg-qh0q">배운 점</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="tg-v0zy">42</td>
        <td class="tg-096r">다양한 의존관계 주입 방법</td>
        <td class="tg-f8tx">29</td>
        <td class="tg-096r"><a href="https://yeonni-history.tistory.com/84" target="_blank" rel="noopener noreferrer">https://yeonni-history.tistory.com/84</a><br><br>- 생성자 주입<br>- 수정자 주입(setter)<br>- 필드 주입<br>- 일반 메서드 주입<br><br></td>
    </tr>
    <tr>
        <td class="tg-v0zy">43</td>
        <td class="tg-096r">옵션처리</td>
        <td class="tg-f8tx">12</td>
        <td class="tg-096r">수정자 주입(setter)를 사용할 경우 @Autowired(required=false) 처리로 option처리가 가능하다. 애플리케이션 시작이후 빈이 생성되는 경우 쓰면 된다. </td>
    </tr>
    <tr>
        <td class="tg-v0zy">44</td>
        <td class="tg-096r">생성자 주입을 선택해라</td>
        <td class="tg-f8tx">12</td>
        <td class="tg-096r">장점은 불변이다.<br>- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없고,<br>- 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안됨.(불변해야 한다.)<br>- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 불변!!!!<br>final 키워드<br>- final을 사용할 수 있으므로, 컴파일 시점에 값이 설정이 되지 않았다면 오류 발생!<br>- 컴파일 오류는 가장 빠르게 원인파악 가능하고, Good 오류다.<br>- 어느 주입 방법도 final을 사용할 수 없음</td>
    </tr>
    <tr>
        <td class="tg-v0zy">45</td>
        <td class="tg-096r">롬복과 최신 트랜드</td>
        <td class="tg-f8tx">11</td>
        <td class="tg-096r">롬복을 적용하면 생성자 주입을 `@RequiredArgsConstructor`로 바로 할 수 있다.</td>
    </tr>
    <tr>
        <td class="tg-v0zy">46</td>
        <td class="tg-096r">조회 빈이 2개 이상 - 문제</td>
        <td class="tg-f8tx">4</td>
        <td class="tg-096r">조회할 빈이 2개이상일 경우 오류 발생함. <br>해결방법은 아래 강의에서!</td>
    </tr>
    <tr>
        <td class="tg-v0zy">47</td>
        <td class="tg-096r">@Autowired 필드 명, @Qualifier, @Primary</td>
        <td class="tg-f8tx">13</td>
        <td class="tg-096r">@Autowired <br>- 타입 매칭<br>- 타입 매칭의 결과가 2개 이상일 떄, 파라미터 명으로 빈이름 매칭<br><br>@Qualifier<br>- 추가 구분자를 붙여줌 <br>-  @Qualifier("mainDiscountPolicy") 이름을 붙히면 그 bean을 가지고 옴<br>- 단점은 주입받을 때 모든 코드에 애노테이션을 붙혀줘야함<br>- primary보다는 qualifier가 우선권이 높다.<br><br>@Primary<br>- 우선순위를 정하는 방법<br>- Autowired시에 여러개가 설정되어있으면 우선권을 가진다.<br><br>@Primary, @Qualifier 활용 <br>메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 편리하게 조회하고<br>서브 데이터베이스 커넥션 빈을 획득할 때는 @Qualifier 를 지정해서 명시적으로 획득 하는 방식 사용<br></td>
    </tr>
    <tr>
        <td class="tg-v0zy">48</td>
        <td class="tg-096r">애노테이션 직접 만들기</td>
        <td class="tg-f8tx">5</td>
        <td class="tg-096r">public @interface AnnotationName<br>스프링이 제공하는 기능을 뚜렷한 목적 없이 무분별하게 재정의하는 것은 좋지 않다.</td>
    </tr>
    <tr>
        <td class="tg-v0zy">49</td>
        <td class="tg-096r">조회한 빈이 모두 필요할 때, List, Map</td>
        <td class="tg-f8tx">11</td>
        <td class="tg-096r">private final Map&lt;String, DiscountPolicy&gt; policyMap; <br>- map의 키에 스프링 빈 이름을 넣어주고, 그 값으로<br>DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담아준다.<br><br>private final List&lt;DiscountPolicy&gt; policies;<br>- DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담아준다.<br><br>호출 결과<br>policyMap = {fixDiscountPolicy=hello.core.discount.FixDiscountPolicy@183e8023, rateDiscountPolicy=hello.core.discount.RateDiscountPolicy@45efc20d} <br><br>policies = [hello.core.discount.FixDiscountPolicy@183e8023, hello.core.discount.RateDiscountPolicy@45efc20d]<br><br><br>DiscountPolicy = policyMap.get("fixDiscountPolicy");<br>이렇게 Name으로 호출할 수 있음</td>
    </tr>
    <tr>
        <td class="tg-v0zy">50</td>
        <td class="tg-096r">자동, 수동의 올바른 실무 운영 기준</td>
        <td class="tg-f8tx">13</td>
        <td class="tg-096r">편리한 자동 기능을 기본으로 사용하자 <br>직접 등록하는 기술 지원 객체는 수동 등록하고,<br>다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자!<br><br>업무 로직 빈 -  자동 기능 적극 활용. 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.<br><br>기술 지원 빈 -  DB설정 등. 애플리케이션에 광범위하게 영햐응ㄹ 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다. </td>
    </tr>
    </tbody>
</table></div>
<p data-ke-size="size16">&nbsp;</p>